# Aula 10: Abstraindo uma aplicação

## Unidade 1: Carregando código de outros arquivos

### Conceito

A aplicação desenvolvida na Aula 9 era suficiente para exibir o currículo de
uma pessoa. Mas se ela é suficiente para exibir um currículo, ela tem que ser
adaptável para exibir quantos currículos nós quisermos. Imagine uma equipe,
querendo exibir o currículo de cada um de seus desenvolvedores e designers, por
exemplo.

Na aplicação que nós construímos, nós começamos definindo diversos arrays com
os dados que precisávamos exibir. Nós poderíamos simplesmente copiar o arquivo
do programa para cada um dos membros da equipe, e depois ir adaptando cada um
deles. Isso seria simples, mas tem dois problemas: primeiro que copiar
arquivos pra uma equipe de 10 pessoas ia ficar muito chato. Segundo que toda vez
que alguma coisa fosse mudar no programa, seria necessário mudar cada um dos
arquivos.

Para nosso time de 10 pessoas, separar as informações em um arquivo separado
vai ser suficiente.

### Desenvolvimento

Então o arquivo `capi.php` vai ter apenas as linhas dos dados, assim:

``` php
<?php

$nome = 'Capi Etheriel';
$profissao = 'Designer de Jogos';
$especialidade = 'Jogos Digitais e Design Colaborativo';

$contato = ['Email' => 'mailto:barraponto@gmail.com',
            'Twitter' => 'http://twitter.com/barraponto',
            'Linkedin' => 'http://linkedin.com/in/barraponto',
            'Github' => 'http://github.com/barraponto'];

$formacao = [['inicio' => 2006,
              'termino' => 2012,
              'instituicao' => 'Universidade Estadual de Campinas',
              'ocupacao' => 'Bacharel em Midialogia'],
             ['inicio' => '2013',
              'termino' => FALSE,
              'instituicao' => 'TimTec',
              'ocupacao' => 'Desenvolvimento PHP']];

$experiencia = [['inicio' => 2013,
                 'termino' => FALSE,
                 'instituicao' => 'Rodada Hacker',
                 'ocupacao' => 'Hacker'],
                ['inicio' => '2013',
                 'termino' => FALSE,
                 'instituicao' => 'Quequere Jogos',
                 'ocupacao' => 'Designer de Jogos']];

$portfolio = [['titulo' => 'Rodada Hacker São Paulo',
               'foto' => 'rodada-sp.jpg',
               'ano' => 2013],
              ['titulo' => 'Cara a Cara do Legislativo',
               'url' => 'http://quequere.com.br/caraacara',
               'ano' => 2013]];

$profhabil = ['html' => 100,
              'css' => 100,
              'javascript' => 60,
              'python' => 50];
```

Preste bastante atenção no fim desse arquivo: nós abrimos a tag `<?php` lá em
cima, para inserir código PHP, mas no fim do arquivo nós não fechamos essa tag.
Isso é uma prática que evita problemas com conteúdo depois do fechamento da
tag. Infelizmente muitos editores de texto ou de código vão inserir uma linha
em branco no fim do arquivo, e se isso estiver fora da tag do PHP, essa linha
vai ser impressa.

Agora nós vamos usar uma função do PHP para inserir essas variáveis no nosso
programa original, que vai ficar assim:

``` php
<?php require_once 'capi.php' ;>
<!doctype html>
<html lang="en">
  ...
</html>
```

Todo o código continua aí exceto os dados que estão definidos no `capi.php`. A
função `require_once` é uma das funções do PHP responsáveis por incluir o
código do arquivo na execução. Ela procura o arquivo indicado e inclui o código
naquele ponto da execução, mas se não encontrar o arquivo, então ela trava a
execução do programa. Afinal, sem as variáveis definidas, nós não teríamos nada
para mostrar ao usuário.

Essa função difere da função `include_once` justamente por parar o programa
caso o arquivo não seja encontrado. E o `require_once` difere da  função
`require` ao inserir o código apenas uma vez. Isto é, se em algum momento nós
escrevermos de novo `require_once 'capi.php'`, nada vai acontecer.

Bom, agora que nós temos os dados separados em outros arquivos, podemos copiar
o arquivo de dados e alterar os valores para outro membro da equipe. Suponha
que daí resultem os arquivos 'gus.php', 'gabi.php' e 'guilherme.php'. Como
podemos fazer para que o programa carregue o currículo certo?

Bom, uma opção razoável é passar a opção na URL. A URL
`http://localhost/curriculo.php?membro=gus` carregaria o currículo do Gus,
enquanto a URL `http://localhost/curriculo.php?membro=gabi` carregaria o
currículo da Gabi.

Por onde começamos? Primeiro, antes do `require_once`, precisamos checar se
esse parâmetro foi enviado. E para evitar que abusem do nosso programa, vamos
checar se esse parâmetro corresponde a algum dos membros da equipe. Só então,
vamos usar esse parâmetro para procurar e carregar o arquivo.

``` php
<?php
$membros = ['capi', 'gus', 'gabi'];
if (!empty($_GET['membro']) && in_array($_GET['membro'], $membros)) {
  require_once $_GET['membro'] . '.php';
}
```

Mas aqui temos um problema: o que acontece se o parâmetro não estiver presente
ou não corresponder a um membro da equipe? Nesse caso deveríamos interromper a
execução -- de preferência dando ao usuário uma opção razoável, como por
exemplo exibindo links para os membros da equipe.

Mas isso implica em ter que escrever um outro HTML, para essa outra condição, o
que faria nosso código ficar muito comprido e difícil de dar manutenção. Então
vamos jogar o nosso HTML original inteiro em outro arquivo, digamos o arquivo
`curriculo-membro.php`.

``` php
<?php
$membros = ['capi', 'gus', 'gabi'];
if (!empty($_GET['membro']) && in_array($_GET['membro'], $membros)) {
  require_once $_GET['membro'] . '.php';
  require_once 'curriculo-membro.php';
}
```

Como você vê, nosso código fica muito mais simples de ler assim, embora agora
tenhamos que abrir um outro arquivo para ver o HTML, o `curriculo-membro.php`.
Por outro lado, quem for responsável pelo HTML e CSS (o *frontend*) agora só
precisa se preocupar com esse arquivo (que costumamos chamar de *Template*).

Não podemos esquecer de colocar o nosos else (que também vai carregar o
arquivo com o HTML das opções):

``` php
else {
  require_once 'curriculo-opcoes.php';
}
```

Esse arquivo vai precisar ter um código HTML completo, com as tags `<HTML>`,
`<HEAD>`, `<BODY>`, etc. A vantagem de usar um formulário é que usando os
atributos certos, esse formulário vai gerar requisições para o programa
`curriculo.php` com os parâmetro certos na URL, porque o formulário é do tipo
`GET`.

``` php
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><?= $nome ?></title>
    <link rel="stylesheet" href="css/bootstrap.min.css" />
  </head>
  <body>
    <div class="container">
    <form action="curriculo.php" method="GET">
      <label for="membro">
        Selecione um dos membros para ver seu curriculo.
      </label>
      <select class="form-control" name="membro">
        <?php foreach ($membros as $membro): ?>
          <option value="<?= $membro ?>">
            <?= uc_words($membro) ?>
          </option>
        <?php endforeach; ?>
      </select>
    </form>
    </div><!-- /container -->
  </body>
</html>
```

### Aplicação

Como você pode ver, separar o código em arquivos separados ajuda a facilitar a
leitura do código, especialmente conforme ele vai ficando mais complexo.
*Complexidade* é o grande inimigo do programador, mas é inevitável conforme nós
queremos fazer mais e mais com os nossos programas.

Nós começamos com o código para exibir um currículo, aproveitando estilos
compartilhados do Bootstrap. Agora nós estamos tentando reaproveitar o código
para exibir os currículos de vários membros de uma equipe. Este processo se
chama *Abstração*.

Conforme a abstração aumenta, a complexidade vai aumentar também. Existem
muitas ferramentas desenhadas para manter a complexidade sob controle, como a
inclusão de arquivos que vimos nesta unidade. Ainda podemos separar as partes
repetitivas do código em funções e especializar os nossos templates, para
evitar a repetição (que é outra inimiga do programador).

Mais para a frente no curso, nós ainda vamos tirar esses arquivos de dados daí
e guardar os dados em um ambiente especializado que é o banco de dados. A
partir daí, vamos poder fazer um aplicativo capaz de gerenciar currículos para
milhares de pessoas -- o que pode ser útil tanto para quem procura emprego
quanto para quem procura novos empregados.

Mas vamos com calma, um passo de cada vez.
